{"file_contents":{"README.md":{"content":"# Issue Tracker\n\nThis is the boilerplate for the Issue Tracker project. Instructions for building your project can be found at https://www.freecodecamp.org/learn/quality-assurance/quality-assurance-projects/issue-tracker\n","size_bytes":221},"assertion-analyser.js":{"content":"/*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*       DO NOT EDIT THIS FILE\n*       For FCC testing purposes!\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*/\n\nfunction objParser(str, init) {\n  // finds objects, arrays, strings, and function arguments\n  // between parens, because they may contain ','\n  let openSym = ['[', '{', '\"', \"'\", '('];\n  let closeSym = [']', '}', '\"', \"'\", ')'];\n  let type;\n  let i;\n  for(i = (init || 0); i < str.length; i++ ) {\n    type = openSym.indexOf(str[i]);\n    if( type !== -1)  break;\n  }\n  if (type === -1) return null;\n  let open = openSym[type];\n  let close = closeSym[type];\n  let count = 1;\n  let k;\n  for(k = i+1; k < str.length; k++) {\n    if(open === '\"' || open === \"'\") {\n      if(str[k] === close) count--;\n      if(str[k] === '\\\\') k++;\n    } else {\n      if(str[k] === open) count++;\n      if(str[k] === close) count--;\n    }\n    if(count === 0) break;\n  }\n  if(count !== 0) return null;\n  let obj = str.slice(i, k+1);\n  return {\n    start : i,\n    end: k,\n    obj: obj\n  };\n}\n\nfunction replacer(str) {\n  // replace objects with a symbol ( __#n)\n  let cnt = 0;\n  let data = [];\n  let obj = objParser(str);\n  while(obj) {\n    data[cnt] = obj.obj;\n    str = str.substring(0, obj.start) + '__#' + cnt++ + str.substring(obj.end+1);\n    obj = objParser(str);\n  }\n  return {\n    str : str,\n    dictionary : data\n  }\n}\n\nfunction splitter(str) {\n  // split on commas, then restore the objects\n  let strObj = replacer(str);\n  let args = strObj.str.split(',');\n  args = args.map(function(a){\n    let m = a.match(/__#(\\d+)/);\n    while (m) {\n      a = a.replace(/__#(\\d+)/, strObj.dictionary[m[1]]);\n      m = a.match(/__#(\\d+)/);\n    }\n    return a.trim();\n  })\n  return args;\n}\n\nfunction assertionAnalyser(body) {\n  \n  // already filtered in the test runner\n  // // remove comments\n  // body = body.replace(/\\/\\/.*\\n|\\/\\*.*\\*\\//g, '');\n  // // get test function body\n  // body = body.match(/\\{\\s*([\\s\\S]*)\\}\\s*$/)[1];\n  \n  if(!body) return \"invalid assertion\";\n  // replace assertions bodies, so that they cannot\n  // contain the word 'assertion'\n\n  let cleanedBody = body.match(/(?:browser\\s*\\.\\s*)?assert\\s*\\.\\s*\\w*\\([\\s\\S]*\\)/)\n  if(cleanedBody && Array.isArray(cleanedBody)) {\n    body = cleanedBody[0];\n  } else {\n    // No assertions present\n    return [];\n  }\n  let s = replacer(body);\n  // split on 'assertion'\n  let splittedAssertions = s.str.split('assert');\n  let assertions = splittedAssertions.slice(1);\n  // match the METHODS\n\n  let assertionBodies = [];\n  let methods = assertions.map(function(a, i){\n    let m = a.match(/^\\s*\\.\\s*(\\w+)__#(\\d+)/);\n    assertionBodies.push(parseInt(m[2]));\n    let pre = splittedAssertions[i].match(/browser\\s*\\.\\s*/) ? 'browser.' : '';\n    return pre + m[1];\n  });\n  if(methods.some(function(m){ return !m })) return \"invalid assertion\";\n  // remove parens from the assertions bodies\n  let bodies = assertionBodies.map(function(b){\n    return s.dictionary[b].slice(1,-1).trim();\n  });\n  assertions = methods.map(function(m, i) {\n    return {\n      method: m,\n      args: splitter(bodies[i]) //replace objects, split on ',' ,then restore objects\n    }\n  })\n  return assertions;\n}\n\nmodule.exports = assertionAnalyser;\n","size_bytes":3161},"replit.md":{"content":"# Overview\n\nThis is a FreeCodeCamp Issue Tracker project - a web application that allows users to create, view, update, and delete issues for different projects. The application serves as a basic project management tool where issues can be tracked with details like title, description, creator, assignee, and status. It's built as a boilerplate project for learning purposes with comprehensive testing support.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Backend Framework\n- **Express.js**: RESTful API server handling HTTP requests and serving static files\n- **Node.js**: Runtime environment for server-side JavaScript execution\n- **Body-parser middleware**: Processes incoming request bodies for form data and JSON\n- **CORS enabled**: Allows cross-origin requests for FreeCodeCamp testing purposes\n\n## API Design\n- **RESTful architecture**: Single endpoint `/api/issues/:project` with HTTP methods (GET, POST, PUT, DELETE)\n- **Project-based routing**: Issues are organized by project name passed as URL parameter\n- **Query parameter filtering**: GET requests support filtering by issue properties\n- **JSON response format**: Standardized data exchange using JSON\n\n## Frontend Architecture\n- **Static HTML pages**: Simple server-side rendered views without frontend frameworks\n- **jQuery integration**: Client-side JavaScript for dynamic interactions and AJAX calls\n- **Responsive design**: Basic CSS styling with mobile-friendly viewport settings\n- **Form-based interactions**: HTML forms for creating and updating issues\n\n## Data Storage\n- **No database implementation**: Current boilerplate contains empty route handlers requiring database integration\n- **In-memory storage anticipated**: Suitable for development and testing phases\n- **Structured data model**: Issues contain fields like _id, issue_title, issue_text, created_by, assigned_to, open status, timestamps\n\n## Testing Framework\n- **Mocha**: Test runner for automated testing suite\n- **Chai**: Assertion library with HTTP testing capabilities via chai-http\n- **Custom test runner**: Specialized test execution system for FreeCodeCamp requirements\n- **TDD approach**: Test-driven development structure with separate functional test files\n\n## File Organization\n- **Routes separation**: API routes isolated in `/routes/api.js` for modularity\n- **Public assets**: Static files (CSS, images) served from `/public` directory\n- **View templates**: HTML files organized in `/views` directory\n- **Test isolation**: Testing files contained in `/tests` directory\n\n# External Dependencies\n\n## Core Dependencies\n- **Express.js (^4.17.1)**: Web application framework for Node.js\n- **Body-parser (^1.19.0)**: Middleware for parsing request bodies\n- **CORS (^2.8.5)**: Cross-Origin Resource Sharing middleware\n- **Dotenv (^8.2.0)**: Environment variable management from .env files\n\n## Testing Dependencies\n- **Mocha (^8.1.3)**: JavaScript testing framework\n- **Chai (^4.2.0)**: Assertion library for testing\n- **Chai-HTTP (^4.3.0)**: HTTP integration testing plugin for Chai\n\n## Development Tools\n- **jQuery (2.2.1)**: Client-side JavaScript library loaded via CDN\n- **FreeCodeCamp testing suite**: Custom testing infrastructure for project validation\n\n## Missing Integrations\n- **Database system**: No database connection configured (MongoDB, PostgreSQL, or similar would be typical)\n- **Authentication system**: No user authentication or session management\n- **Logging system**: No structured logging implementation\n- **Process management**: No production-grade process management (PM2, Forever, etc.)","size_bytes":3614},"server.js":{"content":"'use strict';\n\nconst express     = require('express');\nconst bodyParser  = require('body-parser');\nconst expect      = require('chai').expect;\nconst cors        = require('cors');\nrequire('dotenv').config();\n\nconst apiRoutes         = require('./routes/api.js');\nconst fccTestingRoutes  = require('./routes/fcctesting.js');\nconst runner            = require('./test-runner');\n\nlet app = express();\n\napp.use('/public', express.static(process.cwd() + '/public'));\n\napp.use(cors({origin: '*'})); //For FCC testing purposes only\n\n\n\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\n\n//Sample front-end\napp.route('/:project/')\n  .get(function (req, res) {\n    res.sendFile(process.cwd() + '/views/issue.html');\n  });\n\n//Index page (static HTML)\napp.route('/')\n  .get(function (req, res) {\n    res.sendFile(process.cwd() + '/views/index.html');\n  });\n\n//For FCC testing purposes\nfccTestingRoutes(app);\n\n//Routing for API \napiRoutes(app);  \n    \n//404 Not Found Middleware\napp.use(function(req, res, next) {\n  res.status(404)\n    .type('text')\n    .send('Not Found');\n});\n\n//Start our server and tests!\nconst listener = app.listen(process.env.PORT || 5000, '0.0.0.0', function () {\n  console.log('Your app is listening on port ' + listener.address().port);\n  if(process.env.NODE_ENV==='test') {\n    console.log('Running Tests...');\n    setTimeout(function () {\n      try {\n        runner.run();\n      } catch(e) {\n        console.log('Tests are not valid:');\n        console.error(e);\n      }\n    }, 3500);\n  }\n});\n\nmodule.exports = app; //for testing\n","size_bytes":1575},"test-runner.js":{"content":"/*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*       DO NOT EDIT THIS FILE\n*       For FCC testing purposes!\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*/\n\nconst analyser = require('./assertion-analyser');\nconst EventEmitter = require('events').EventEmitter;\n\nconst Mocha = require('mocha'),\n    fs = require('fs'),\n    path = require('path');\n\nconst mocha = new Mocha();\nlet testDir = './tests'\n\n\n// Add each .js file to the mocha instance\nfs.readdirSync(testDir).filter(function(file){\n    // Only keep the .js files\n    return file.substr(-3) === '.js';\n\n}).forEach(function(file){\n    mocha.addFile(\n        path.join(testDir, file)\n    );\n});\n\nlet emitter = new EventEmitter();\nemitter.run = function() {\n\n  let tests = [];\n  let context = \"\";\n  let separator = ' -> ';\n  // Run the tests.\n  try {\n  let runner = mocha.ui('tdd').run()\n    .on('test end', function(test) {\n        // remove comments\n        let body = test.body.replace(/\\/\\/.*\\n|\\/\\*.*\\*\\//g, '');\n        // collapse spaces\n        body = body.replace(/\\s+/g,' ');\n        let obj = {\n          title: test.title,\n          context: context.slice(0, -separator.length),\n          state: test.state,\n          // body: body,\n          assertions: analyser(body)\n        };\n        tests.push(obj);\n    })\n    .on('end', function() {\n        emitter.report = tests;\n        emitter.emit('done', tests)\n    })\n    .on('suite', function(s) {\n      context += (s.title + separator);\n\n    })\n    .on('suite end', function(s) {\n      context = context.slice(0, -(s.title.length + separator.length))\n    })\n  } catch(e) {\n    throw(e);\n  }\n};\n\nmodule.exports = emitter;\n\n/*\n * Mocha.runner Events:\n * can be used to build a better custom report\n *\n *   - `start`  execution started\n *   - `end`  execution complete\n *   - `suite`  (suite) test suite execution started\n *   - `suite end`  (suite) all tests (and sub-suites) have finished\n *   - `test`  (test) test execution started\n *   - `test end`  (test) test completed\n *   - `hook`  (hook) hook execution started\n *   - `hook end`  (hook) hook complete\n *   - `pass`  (test) test passed\n *   - `fail`  (test, err) test failed\n *   - `pending`  (test) test pending\n */","size_bytes":2146},"public/style.css":{"content":"* {\n  margin: 0px;\n  padding: 0px;\n}\n\nbody {\n  padding: 10px;\n}\n\n.issue {\n  margin: 20px;\n  padding: 5px;\n  width: 60%;\n  border: 2px solid black;\n}\n\n.closed {\n  background-color: lightgrey;\n}\n\n.id {\n  font-size: 10.5px;\n}","size_bytes":222},"routes/api.js":{"content":"'use strict';\n\n// In-memory storage for issues (organized by project)\nlet issues = {};\nlet idCounter = 1;\n\nmodule.exports = function (app) {\n\n  app.route('/api/issues/:project')\n  \n    .get(function (req, res){\n      let project = req.params.project;\n      \n      // Initialize project issues if not exists\n      if (!issues[project]) {\n        issues[project] = [];\n      }\n      \n      let projectIssues = issues[project];\n      \n      // Apply filters from query parameters\n      let filteredIssues = projectIssues.filter(issue => {\n        for (let key in req.query) {\n          if (req.query[key] !== undefined && req.query[key] !== '') {\n            // Convert boolean strings for 'open' field\n            if (key === 'open') {\n              let queryValue;\n              if (req.query[key] === 'true') {\n                queryValue = true;\n              } else if (req.query[key] === 'false') {\n                queryValue = false;\n              } else {\n                queryValue = req.query[key] === 'true'; // fallback behavior\n              }\n              if (issue[key] !== queryValue) {\n                return false;\n              }\n            } else {\n              // Handle string comparison for other fields\n              if (String(issue[key]) !== String(req.query[key])) {\n                return false;\n              }\n            }\n          }\n        }\n        return true;\n      });\n      \n      res.json(filteredIssues);\n    })\n    \n    .post(function (req, res){\n      let project = req.params.project;\n      \n      // Check required fields\n      if (!req.body.issue_title || !req.body.issue_text || !req.body.created_by) {\n        return res.json({ error: 'required field(s) missing' });\n      }\n      \n      // Initialize project issues if not exists\n      if (!issues[project]) {\n        issues[project] = [];\n      }\n      \n      // Create new issue\n      let newIssue = {\n        _id: (idCounter++).toString(),\n        issue_title: req.body.issue_title,\n        issue_text: req.body.issue_text,\n        created_by: req.body.created_by,\n        assigned_to: req.body.assigned_to || '',\n        status_text: req.body.status_text || '',\n        created_on: new Date().toISOString(),\n        updated_on: new Date().toISOString(),\n        open: true\n      };\n      \n      // Add to project issues\n      issues[project].push(newIssue);\n      \n      res.json(newIssue);\n    })\n    \n    .put(function (req, res){\n      let project = req.params.project;\n      \n      // Check if _id is provided\n      if (!req.body._id) {\n        return res.json({ error: 'missing _id' });\n      }\n      \n      // Initialize project issues if not exists\n      if (!issues[project]) {\n        issues[project] = [];\n      }\n      \n      let issueId = req.body._id.toString();\n      let issueIndex = issues[project].findIndex(issue => issue._id === issueId);\n      \n      if (issueIndex === -1) {\n        return res.json({ error: 'could not update', '_id': String(req.body._id) });\n      }\n      \n      // Check if there are fields to update (excluding _id)\n      // Define which fields are valid for updating\n      const validUpdateFields = ['issue_title', 'issue_text', 'created_by', 'assigned_to', 'status_text', 'open'];\n      \n      // Only look at fields that are both present in request AND in valid fields list\n      let updateFields = [];\n      \n      validUpdateFields.forEach(field => {\n        if (req.body.hasOwnProperty(field)) {\n          let value = req.body[field];\n          \n          // Special handling for 'open' field - false and 'false' are valid values  \n          if (field === 'open') {\n            if (value !== undefined && value !== null && value !== '') {\n              updateFields.push(field);\n            }\n          } else {\n            // For other fields, empty strings, null, and undefined are NOT valid\n            if (value !== undefined && value !== null && value !== '') {\n              updateFields.push(field);\n            }\n          }\n        }\n      });\n      \n      if (updateFields.length === 0) {\n        return res.json({ error: 'no update field(s) sent', '_id': String(req.body._id) });\n      }\n      \n      // Update issue fields\n      let issue = issues[project][issueIndex];\n      \n      // Update only the validated fields\n      updateFields.forEach(field => {\n        let value = req.body[field];\n        if (field === 'open') {\n          // Handle boolean conversion for open field\n          if (value === 'false' || value === false) {\n            issue[field] = false;\n          } else if (value === 'true' || value === true) {\n            issue[field] = true;\n          } else {\n            issue[field] = true; // default to true for any other value\n          }\n        } else {\n          // Update field with the provided value\n          issue[field] = value;\n        }\n      });\n      \n      issue.updated_on = new Date().toISOString();\n      res.json({ result: 'successfully updated', '_id': String(req.body._id) });\n    })\n    \n    .delete(function (req, res){\n      let project = req.params.project;\n      \n      // Check if _id is provided\n      if (!req.body._id) {\n        return res.json({ error: 'missing _id' });\n      }\n      \n      // Initialize project issues if not exists\n      if (!issues[project]) {\n        issues[project] = [];\n      }\n      \n      let issueId = req.body._id.toString();\n      let issueIndex = issues[project].findIndex(issue => issue._id === issueId);\n      \n      if (issueIndex === -1) {\n        return res.json({ error: 'could not delete', '_id': String(req.body._id) });\n      }\n      \n      // Remove issue\n      issues[project].splice(issueIndex, 1);\n      res.json({ result: 'successfully deleted', '_id': String(req.body._id) });\n    });\n    \n};\n","size_bytes":5754},"routes/fcctesting.js":{"content":"/*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*       DO NOT EDIT THIS FILE\n*       For FCC testing purposes!\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*/\n\n'use strict';\n\nconst cors = require('cors');\nconst fs = require('fs');\nconst runner = require('../test-runner');\n\nmodule.exports = function (app) {\n\n  app.route('/_api/server.js')\n    .get(function(req, res, next) {\n      console.log('requested');\n      fs.readFile(__dirname + '/server.js', function(err, data) {\n        if(err) return next(err);\n        res.send(data.toString());\n      });\n    });\n  app.route('/_api/routes/api.js')\n    .get(function(req, res, next) {\n      console.log('requested');\n      fs.readFile(__dirname + '/routes/api.js', function(err, data) {\n        if(err) return next(err);\n        res.type('txt').send(data.toString());\n      });\n    });\n\n  app.get('/_api/get-tests', cors(), function(req, res, next){\n    console.log('requested');\n    if(process.env.NODE_ENV === 'test') return next();\n    res.json({status: 'unavailable'});\n  },\n  function(req, res, next){\n    if(!runner.report) return next();\n    res.json(testFilter(runner.report, req.query.type, req.query.n));\n  },\n  function(req, res){\n    runner.on('done', function(report){\n      process.nextTick(() =>  res.json(testFilter(runner.report, req.query.type, req.query.n)));\n    });\n  });\n};\n\nfunction testFilter(tests, type, n) {\n  let out;\n  switch (type) {\n    case 'unit' :\n      out = tests.filter(t => t.context.match('Unit Tests'));\n      break;\n    case 'functional':\n      out = tests.filter(t => t.context.match('Functional Tests') && !t.title.match('#example'));\n      break;\n    default:\n      out = tests;\n  }\n  if(n !== undefined) {\n    return out[n] || out;\n  }\n  return out;\n}","size_bytes":1698},"tests/2_functional-tests.js":{"content":"const chaiHttp = require('chai-http');\nconst chai = require('chai');\nconst assert = chai.assert;\nconst server = require('../server');\n\nchai.use(chaiHttp);\n\nsuite('Functional Tests', function() {\n  \n  let testId; // Store issue ID for update/delete tests\n  \n  suite('POST /api/issues/{project} => object with issue data', function() {\n    \n    test('Every field filled in', function(done) {\n      chai.request(server)\n        .post('/api/issues/test')\n        .send({\n          issue_title: 'Title',\n          issue_text: 'text',\n          created_by: 'Functional Test - Every field filled in',\n          assigned_to: 'Chai and Mocha',\n          status_text: 'In QA'\n        })\n        .end(function(err, res){\n          assert.equal(res.status, 200);\n          assert.equal(res.body.issue_title, 'Title');\n          assert.equal(res.body.issue_text, 'text');\n          assert.equal(res.body.created_by, 'Functional Test - Every field filled in');\n          assert.equal(res.body.assigned_to, 'Chai and Mocha');\n          assert.equal(res.body.status_text, 'In QA');\n          assert.property(res.body, 'created_on');\n          assert.property(res.body, 'updated_on');\n          assert.property(res.body, '_id');\n          assert.isTrue(res.body.open);\n          testId = res.body._id; // Store for later tests\n          done();\n        });\n    });\n    \n    test('Required fields filled in', function(done) {\n      chai.request(server)\n        .post('/api/issues/test')\n        .send({\n          issue_title: 'Title',\n          issue_text: 'text',\n          created_by: 'Functional Test - Required fields filled in'\n        })\n        .end(function(err, res){\n          assert.equal(res.status, 200);\n          assert.equal(res.body.issue_title, 'Title');\n          assert.equal(res.body.issue_text, 'text');\n          assert.equal(res.body.created_by, 'Functional Test - Required fields filled in');\n          assert.equal(res.body.assigned_to, '');\n          assert.equal(res.body.status_text, '');\n          assert.property(res.body, 'created_on');\n          assert.property(res.body, 'updated_on');\n          assert.property(res.body, '_id');\n          assert.isTrue(res.body.open);\n          done();\n        });\n    });\n    \n    test('Missing required fields', function(done) {\n      chai.request(server)\n        .post('/api/issues/test')\n        .send({\n          issue_title: 'Title',\n          issue_text: 'text'\n        })\n        .end(function(err, res){\n          assert.equal(res.status, 200);\n          assert.equal(res.body.error, 'required field(s) missing');\n          done();\n        });\n    });\n    \n  });\n  \n  suite('PUT /api/issues/{project} => text', function() {\n    \n    test('No body', function(done) {\n      chai.request(server)\n        .put('/api/issues/test')\n        .send({})\n        .end(function(err, res){\n          assert.equal(res.status, 200);\n          assert.equal(res.body.error, 'missing _id');\n          done();\n        });\n    });\n    \n    test('One field to update', function(done) {\n      chai.request(server)\n        .put('/api/issues/test')\n        .send({\n          _id: testId,\n          issue_text: 'new text'\n        })\n        .end(function(err, res){\n          assert.equal(res.status, 200);\n          assert.equal(res.body.result, 'successfully updated');\n          assert.equal(res.body._id, testId);\n          done();\n        });\n    });\n    \n    test('Multiple fields to update', function(done) {\n      chai.request(server)\n        .put('/api/issues/test')\n        .send({\n          _id: testId,\n          issue_title: 'new title',\n          issue_text: 'new text',\n          assigned_to: 'new assigned'\n        })\n        .end(function(err, res){\n          assert.equal(res.status, 200);\n          assert.equal(res.body.result, 'successfully updated');\n          assert.equal(res.body._id, testId);\n          done();\n        });\n    });\n    \n    test('No fields to update', function(done) {\n      chai.request(server)\n        .put('/api/issues/test')\n        .send({\n          _id: testId\n        })\n        .end(function(err, res){\n          assert.equal(res.status, 200);\n          assert.equal(res.body.error, 'no update field(s) sent');\n          assert.equal(res.body._id, testId);\n          done();\n        });\n    });\n    \n    test('Invalid _id', function(done) {\n      chai.request(server)\n        .put('/api/issues/test')\n        .send({\n          _id: 99999,\n          issue_title: 'new title'\n        })\n        .end(function(err, res){\n          assert.equal(res.status, 200);\n          assert.equal(res.body.error, 'could not update');\n          assert.equal(res.body._id, '99999');\n          done();\n        });\n    });\n    \n  });\n  \n  suite('GET /api/issues/{project} => Array of objects with issue data', function() {\n    \n    test('No filter', function(done) {\n      chai.request(server)\n        .get('/api/issues/test')\n        .query({})\n        .end(function(err, res){\n          assert.equal(res.status, 200);\n          assert.isArray(res.body);\n          assert.property(res.body[0], 'issue_title');\n          assert.property(res.body[0], 'issue_text');\n          assert.property(res.body[0], 'created_on');\n          assert.property(res.body[0], 'updated_on');\n          assert.property(res.body[0], 'created_by');\n          assert.property(res.body[0], 'assigned_to');\n          assert.property(res.body[0], 'open');\n          assert.property(res.body[0], 'status_text');\n          assert.property(res.body[0], '_id');\n          done();\n        });\n    });\n    \n    test('One filter', function(done) {\n      chai.request(server)\n        .get('/api/issues/test')\n        .query({ assigned_to: 'new assigned' })\n        .end(function(err, res){\n          assert.equal(res.status, 200);\n          assert.isArray(res.body);\n          res.body.forEach(issue => {\n            assert.equal(issue.assigned_to, 'new assigned');\n          });\n          done();\n        });\n    });\n    \n    test('Multiple filters (test for open and assigned_to)', function(done) {\n      chai.request(server)\n        .get('/api/issues/test')\n        .query({\n          open: true,\n          assigned_to: 'new assigned'\n        })\n        .end(function(err, res){\n          assert.equal(res.status, 200);\n          assert.isArray(res.body);\n          res.body.forEach(issue => {\n            assert.equal(issue.open, true);\n            assert.equal(issue.assigned_to, 'new assigned');\n          });\n          done();\n        });\n    });\n    \n  });\n  \n  suite('DELETE /api/issues/{project} => text', function() {\n    \n    test('No _id', function(done) {\n      chai.request(server)\n        .delete('/api/issues/test')\n        .send({})\n        .end(function(err, res){\n          assert.equal(res.status, 200);\n          assert.equal(res.body.error, 'missing _id');\n          done();\n        });\n    });\n    \n    test('Invalid _id', function(done) {\n      chai.request(server)\n        .delete('/api/issues/test')\n        .send({\n          _id: 99999\n        })\n        .end(function(err, res){\n          assert.equal(res.status, 200);\n          assert.equal(res.body.error, 'could not delete');\n          assert.equal(res.body._id, '99999');\n          done();\n        });\n    });\n    \n    test('Valid _id', function(done) {\n      chai.request(server)\n        .delete('/api/issues/test')\n        .send({\n          _id: testId\n        })\n        .end(function(err, res){\n          assert.equal(res.status, 200);\n          assert.equal(res.body.result, 'successfully deleted');\n          assert.equal(res.body._id, testId);\n          done();\n        });\n    });\n    \n  });\n\n});\n","size_bytes":7621}},"version":1}